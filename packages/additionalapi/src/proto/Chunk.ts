// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.1
//   protoc               v5.27.1
// source: packages/additionalapi/src/proto/Chunk.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal.js";

export const protobufPackage = "io.lionweb.lioncore.protobuf";

export interface BulkImport {
  metaPointerDefs: MetaPointerDef[];
  elements: BulkImportElement[];
}

export interface BulkImportElement {
  container: string;
  metaPointerIndex: number;
  tree: Node[];
}

export interface Chunk {
  serializationFormatVersion: string;
  languages: Language[];
  nodes: Node[];
  metaPointerDefs: MetaPointerDef[];
}

export interface MetaPointerDef {
  language: string;
  version: string;
  key: string;
  index: number;
}

export interface Language {
  key: string;
  version: string;
}

export interface Node {
  id: string;
  classifier: Classifier | undefined;
  properties: Property[];
  containments: Containment[];
  references: Reference[];
  annotations: Annotation[];
  /** optinal */
  parent: string;
}

export interface Classifier {
  language: string;
  version: string;
  key: string;
}

export interface MetaPointer {
  language: string;
  version: string;
  key: string;
}

export interface Property {
  /** MetaPointer metapointer = 1; */
  metaPointerIndex: number;
  /** optinal */
  value: string;
}

export interface Containment {
  /** MetaPointer metapointer = 1; */
  metaPointerIndex: number;
  children: string[];
}

export interface Reference {
  /** MetaPointer metapointer = 1; */
  metaPointerIndex: number;
  values: ReferenceValue[];
}

export interface Annotation {
}

export interface ReferenceValue {
  /** optinal */
  resolveInfo: string;
  /** optinal */
  referred: string;
}

function createBaseBulkImport(): BulkImport {
  return { metaPointerDefs: [], elements: [] };
}

export const BulkImport = {
  encode(message: BulkImport, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.metaPointerDefs) {
      MetaPointerDef.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.elements) {
      BulkImportElement.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkImport {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkImport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metaPointerDefs.push(MetaPointerDef.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.elements.push(BulkImportElement.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BulkImport {
    return {
      metaPointerDefs: globalThis.Array.isArray(object?.metaPointerDefs)
        ? object.metaPointerDefs.map((e: any) => MetaPointerDef.fromJSON(e))
        : [],
      elements: globalThis.Array.isArray(object?.elements)
        ? object.elements.map((e: any) => BulkImportElement.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BulkImport): unknown {
    const obj: any = {};
    if (message.metaPointerDefs?.length) {
      obj.metaPointerDefs = message.metaPointerDefs.map((e) => MetaPointerDef.toJSON(e));
    }
    if (message.elements?.length) {
      obj.elements = message.elements.map((e) => BulkImportElement.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkImport>, I>>(base?: I): BulkImport {
    return BulkImport.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkImport>, I>>(object: I): BulkImport {
    const message = createBaseBulkImport();
    message.metaPointerDefs = object.metaPointerDefs?.map((e) => MetaPointerDef.fromPartial(e)) || [];
    message.elements = object.elements?.map((e) => BulkImportElement.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBulkImportElement(): BulkImportElement {
  return { container: "", metaPointerIndex: 0, tree: [] };
}

export const BulkImportElement = {
  encode(message: BulkImportElement, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.container !== "") {
      writer.uint32(10).string(message.container);
    }
    if (message.metaPointerIndex !== 0) {
      writer.uint32(16).uint32(message.metaPointerIndex);
    }
    for (const v of message.tree) {
      Node.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkImportElement {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkImportElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.container = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.metaPointerIndex = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tree.push(Node.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BulkImportElement {
    return {
      container: isSet(object.container) ? globalThis.String(object.container) : "",
      metaPointerIndex: isSet(object.metaPointerIndex) ? globalThis.Number(object.metaPointerIndex) : 0,
      tree: globalThis.Array.isArray(object?.tree) ? object.tree.map((e: any) => Node.fromJSON(e)) : [],
    };
  },

  toJSON(message: BulkImportElement): unknown {
    const obj: any = {};
    if (message.container !== "") {
      obj.container = message.container;
    }
    if (message.metaPointerIndex !== 0) {
      obj.metaPointerIndex = Math.round(message.metaPointerIndex);
    }
    if (message.tree?.length) {
      obj.tree = message.tree.map((e) => Node.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BulkImportElement>, I>>(base?: I): BulkImportElement {
    return BulkImportElement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BulkImportElement>, I>>(object: I): BulkImportElement {
    const message = createBaseBulkImportElement();
    message.container = object.container ?? "";
    message.metaPointerIndex = object.metaPointerIndex ?? 0;
    message.tree = object.tree?.map((e) => Node.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChunk(): Chunk {
  return { serializationFormatVersion: "", languages: [], nodes: [], metaPointerDefs: [] };
}

export const Chunk = {
  encode(message: Chunk, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.serializationFormatVersion !== "") {
      writer.uint32(10).string(message.serializationFormatVersion);
    }
    for (const v of message.languages) {
      Language.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.nodes) {
      Node.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.metaPointerDefs) {
      MetaPointerDef.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Chunk {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serializationFormatVersion = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.languages.push(Language.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nodes.push(Node.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.metaPointerDefs.push(MetaPointerDef.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Chunk {
    return {
      serializationFormatVersion: isSet(object.serializationFormatVersion)
        ? globalThis.String(object.serializationFormatVersion)
        : "",
      languages: globalThis.Array.isArray(object?.languages)
        ? object.languages.map((e: any) => Language.fromJSON(e))
        : [],
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => Node.fromJSON(e)) : [],
      metaPointerDefs: globalThis.Array.isArray(object?.metaPointerDefs)
        ? object.metaPointerDefs.map((e: any) => MetaPointerDef.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Chunk): unknown {
    const obj: any = {};
    if (message.serializationFormatVersion !== "") {
      obj.serializationFormatVersion = message.serializationFormatVersion;
    }
    if (message.languages?.length) {
      obj.languages = message.languages.map((e) => Language.toJSON(e));
    }
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => Node.toJSON(e));
    }
    if (message.metaPointerDefs?.length) {
      obj.metaPointerDefs = message.metaPointerDefs.map((e) => MetaPointerDef.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Chunk>, I>>(base?: I): Chunk {
    return Chunk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Chunk>, I>>(object: I): Chunk {
    const message = createBaseChunk();
    message.serializationFormatVersion = object.serializationFormatVersion ?? "";
    message.languages = object.languages?.map((e) => Language.fromPartial(e)) || [];
    message.nodes = object.nodes?.map((e) => Node.fromPartial(e)) || [];
    message.metaPointerDefs = object.metaPointerDefs?.map((e) => MetaPointerDef.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMetaPointerDef(): MetaPointerDef {
  return { language: "", version: "", key: "", index: 0 };
}

export const MetaPointerDef = {
  encode(message: MetaPointerDef, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.language !== "") {
      writer.uint32(10).string(message.language);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.key !== "") {
      writer.uint32(26).string(message.key);
    }
    if (message.index !== 0) {
      writer.uint32(32).uint32(message.index);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetaPointerDef {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetaPointerDef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.language = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.key = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.index = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetaPointerDef {
    return {
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
    };
  },

  toJSON(message: MetaPointerDef): unknown {
    const obj: any = {};
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetaPointerDef>, I>>(base?: I): MetaPointerDef {
    return MetaPointerDef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetaPointerDef>, I>>(object: I): MetaPointerDef {
    const message = createBaseMetaPointerDef();
    message.language = object.language ?? "";
    message.version = object.version ?? "";
    message.key = object.key ?? "";
    message.index = object.index ?? 0;
    return message;
  },
};

function createBaseLanguage(): Language {
  return { key: "", version: "" };
}

export const Language = {
  encode(message: Language, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Language {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLanguage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Language {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
    };
  },

  toJSON(message: Language): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Language>, I>>(base?: I): Language {
    return Language.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Language>, I>>(object: I): Language {
    const message = createBaseLanguage();
    message.key = object.key ?? "";
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseNode(): Node {
  return {
    id: "",
    classifier: undefined,
    properties: [],
    containments: [],
    references: [],
    annotations: [],
    parent: "",
  };
}

export const Node = {
  encode(message: Node, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.classifier !== undefined) {
      Classifier.encode(message.classifier, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.containments) {
      Containment.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.references) {
      Reference.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.annotations) {
      Annotation.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.parent !== "") {
      writer.uint32(58).string(message.parent);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Node {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.classifier = Classifier.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.containments.push(Containment.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.references.push(Reference.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.annotations.push(Annotation.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.parent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      classifier: isSet(object.classifier) ? Classifier.fromJSON(object.classifier) : undefined,
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
      containments: globalThis.Array.isArray(object?.containments)
        ? object.containments.map((e: any) => Containment.fromJSON(e))
        : [],
      references: globalThis.Array.isArray(object?.references)
        ? object.references.map((e: any) => Reference.fromJSON(e))
        : [],
      annotations: globalThis.Array.isArray(object?.annotations)
        ? object.annotations.map((e: any) => Annotation.fromJSON(e))
        : [],
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
    };
  },

  toJSON(message: Node): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.classifier !== undefined) {
      obj.classifier = Classifier.toJSON(message.classifier);
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    if (message.containments?.length) {
      obj.containments = message.containments.map((e) => Containment.toJSON(e));
    }
    if (message.references?.length) {
      obj.references = message.references.map((e) => Reference.toJSON(e));
    }
    if (message.annotations?.length) {
      obj.annotations = message.annotations.map((e) => Annotation.toJSON(e));
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Node>, I>>(base?: I): Node {
    return Node.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Node>, I>>(object: I): Node {
    const message = createBaseNode();
    message.id = object.id ?? "";
    message.classifier = (object.classifier !== undefined && object.classifier !== null)
      ? Classifier.fromPartial(object.classifier)
      : undefined;
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    message.containments = object.containments?.map((e) => Containment.fromPartial(e)) || [];
    message.references = object.references?.map((e) => Reference.fromPartial(e)) || [];
    message.annotations = object.annotations?.map((e) => Annotation.fromPartial(e)) || [];
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBaseClassifier(): Classifier {
  return { language: "", version: "", key: "" };
}

export const Classifier = {
  encode(message: Classifier, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.language !== "") {
      writer.uint32(10).string(message.language);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.key !== "") {
      writer.uint32(26).string(message.key);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Classifier {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClassifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.language = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.key = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Classifier {
    return {
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
    };
  },

  toJSON(message: Classifier): unknown {
    const obj: any = {};
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Classifier>, I>>(base?: I): Classifier {
    return Classifier.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Classifier>, I>>(object: I): Classifier {
    const message = createBaseClassifier();
    message.language = object.language ?? "";
    message.version = object.version ?? "";
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseMetaPointer(): MetaPointer {
  return { language: "", version: "", key: "" };
}

export const MetaPointer = {
  encode(message: MetaPointer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.language !== "") {
      writer.uint32(10).string(message.language);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.key !== "") {
      writer.uint32(26).string(message.key);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetaPointer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetaPointer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.language = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.key = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetaPointer {
    return {
      language: isSet(object.language) ? globalThis.String(object.language) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
    };
  },

  toJSON(message: MetaPointer): unknown {
    const obj: any = {};
    if (message.language !== "") {
      obj.language = message.language;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetaPointer>, I>>(base?: I): MetaPointer {
    return MetaPointer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetaPointer>, I>>(object: I): MetaPointer {
    const message = createBaseMetaPointer();
    message.language = object.language ?? "";
    message.version = object.version ?? "";
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseProperty(): Property {
  return { metaPointerIndex: 0, value: "" };
}

export const Property = {
  encode(message: Property, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.metaPointerIndex !== 0) {
      writer.uint32(8).uint32(message.metaPointerIndex);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Property {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProperty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.metaPointerIndex = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Property {
    return {
      metaPointerIndex: isSet(object.metaPointerIndex) ? globalThis.Number(object.metaPointerIndex) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Property): unknown {
    const obj: any = {};
    if (message.metaPointerIndex !== 0) {
      obj.metaPointerIndex = Math.round(message.metaPointerIndex);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Property>, I>>(base?: I): Property {
    return Property.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Property>, I>>(object: I): Property {
    const message = createBaseProperty();
    message.metaPointerIndex = object.metaPointerIndex ?? 0;
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseContainment(): Containment {
  return { metaPointerIndex: 0, children: [] };
}

export const Containment = {
  encode(message: Containment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.metaPointerIndex !== 0) {
      writer.uint32(8).uint32(message.metaPointerIndex);
    }
    for (const v of message.children) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Containment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContainment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.metaPointerIndex = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.children.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Containment {
    return {
      metaPointerIndex: isSet(object.metaPointerIndex) ? globalThis.Number(object.metaPointerIndex) : 0,
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Containment): unknown {
    const obj: any = {};
    if (message.metaPointerIndex !== 0) {
      obj.metaPointerIndex = Math.round(message.metaPointerIndex);
    }
    if (message.children?.length) {
      obj.children = message.children;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Containment>, I>>(base?: I): Containment {
    return Containment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Containment>, I>>(object: I): Containment {
    const message = createBaseContainment();
    message.metaPointerIndex = object.metaPointerIndex ?? 0;
    message.children = object.children?.map((e) => e) || [];
    return message;
  },
};

function createBaseReference(): Reference {
  return { metaPointerIndex: 0, values: [] };
}

export const Reference = {
  encode(message: Reference, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.metaPointerIndex !== 0) {
      writer.uint32(8).uint32(message.metaPointerIndex);
    }
    for (const v of message.values) {
      ReferenceValue.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Reference {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.metaPointerIndex = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.values.push(ReferenceValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Reference {
    return {
      metaPointerIndex: isSet(object.metaPointerIndex) ? globalThis.Number(object.metaPointerIndex) : 0,
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => ReferenceValue.fromJSON(e)) : [],
    };
  },

  toJSON(message: Reference): unknown {
    const obj: any = {};
    if (message.metaPointerIndex !== 0) {
      obj.metaPointerIndex = Math.round(message.metaPointerIndex);
    }
    if (message.values?.length) {
      obj.values = message.values.map((e) => ReferenceValue.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Reference>, I>>(base?: I): Reference {
    return Reference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Reference>, I>>(object: I): Reference {
    const message = createBaseReference();
    message.metaPointerIndex = object.metaPointerIndex ?? 0;
    message.values = object.values?.map((e) => ReferenceValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAnnotation(): Annotation {
  return {};
}

export const Annotation = {
  encode(_: Annotation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Annotation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Annotation {
    return {};
  },

  toJSON(_: Annotation): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Annotation>, I>>(base?: I): Annotation {
    return Annotation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Annotation>, I>>(_: I): Annotation {
    const message = createBaseAnnotation();
    return message;
  },
};

function createBaseReferenceValue(): ReferenceValue {
  return { resolveInfo: "", referred: "" };
}

export const ReferenceValue = {
  encode(message: ReferenceValue, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.resolveInfo !== "") {
      writer.uint32(10).string(message.resolveInfo);
    }
    if (message.referred !== "") {
      writer.uint32(18).string(message.referred);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReferenceValue {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReferenceValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resolveInfo = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.referred = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReferenceValue {
    return {
      resolveInfo: isSet(object.resolveInfo) ? globalThis.String(object.resolveInfo) : "",
      referred: isSet(object.referred) ? globalThis.String(object.referred) : "",
    };
  },

  toJSON(message: ReferenceValue): unknown {
    const obj: any = {};
    if (message.resolveInfo !== "") {
      obj.resolveInfo = message.resolveInfo;
    }
    if (message.referred !== "") {
      obj.referred = message.referred;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReferenceValue>, I>>(base?: I): ReferenceValue {
    return ReferenceValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReferenceValue>, I>>(object: I): ReferenceValue {
    const message = createBaseReferenceValue();
    message.resolveInfo = object.resolveInfo ?? "";
    message.referred = object.referred ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
